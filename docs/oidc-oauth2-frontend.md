# OIDC/OAuth 2.0 実装と設計の勘所：フロントエンドの責務

## 1. 認証（Authentication）と認可（Authorization）の分離

- **Authentication (OIDC):** 「誰であるか」を証明する。ID トークン（JWT）を受け取り、ユーザー情報を取得する。
- **Authorization (OAuth 2.0):** 「何ができるか」を許可する。アクセストークンを受け取り、API リソースへのアクセス権を得る。
- **プロジェクトでの教訓:** フロントエンドは ID トークンからユーザー属性を表示し、アクセストークンをヘッダーに付与して BE へリクエストを投げる役割を明確に分ける。

## 2. 採用フロー：Authorization Code Flow with PKCE

- **なぜ PKCE か:** フロントエンド（Public Client）において、クライアントシークレットを保持できない環境でのコード横取り攻撃を防ぐため。
- **シーケンスの理解:**
  1. FE: code_verifier を生成し、そのハッシュ値(code_challenge)と共に認可リクエスト。
  2. 認可サーバー: 認可コードを発行。
  3. FE: 認可コードと code_verifier をトークンエンドポイントへ送信。
  4. 認可サーバー: ハッシュ値の検証を行い、トークンを発行。

## 3. トークン管理とセキュリティ

- **ID Token:** 基本的にステートレスにユーザー情報を扱うために使用。署名検証（RS256 等）の重要性を認識。
- **Access Token:** 有効期限（exp）の監視と、期限切れ時のリフレッシュトークンによる再取得フローの設計。
- **ストレージの選択:** セキュリティ要件に応じ、メモリ内管理、または HttpOnly クッキー（BE 側でのセット）の検討。

## 4. FE/BE 境界線の設計（マルチベンダー環境での最適化）

- **インターフェースの先行定義:** BE の完成を待たず、期待されるクレーム（sub, email, roles 等）やエラーレスポンスの形式を定義することで、開発のブロッキングを回避した。
- **共通の理解:** 「どのエンドポイントがどのスコープを要求するか」を BE チームと早期に合意することが、手戻りを防ぐ最大の鍵であった。
