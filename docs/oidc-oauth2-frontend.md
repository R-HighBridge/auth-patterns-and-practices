# OIDC/OAuth 2.0 実装と設計の勘所：フロントエンドの責務

本ドキュメントでは、React 19 / Next.js 15 を用いたモダンなフロントエンド開発における、認証・認可の実装指針をまとめています。特にマルチベンダー環境や SPA におけるセキュリティの妥当性を重視しています。

---

## 1. 認証（Authentication）と認可（Authorization）の分離

フロントエンドの設計において、これら二つの責務を明確に分離することが、堅牢なアーキテクチャの第一歩です。

- **Authentication (OIDC):** 「誰であるか」を証明する。
  - 認可サーバーから返却される **ID トークン (JWT)** をデコードし、ユーザー名やメールアドレス、ロールを取得。
  - フロントエンドの UI 制御（メニューの表示・非表示、プロフィールの表示）に使用する。
- **Authorization (OAuth 2.0):** 「何ができるか」を許可する。
  - **アクセスコード (Access Token)** を取得し、Backend API へのリクエストヘッダー（`Authorization: Bearer <Token>`）に付与する。
- **設計の要点:** フロントエンドは ID トークンを「表示用」、アクセストークンを「通信用」として扱い、BE へのリクエストに ID トークンを流用しない。

---

## 2. Authorization Code Flow with PKCE (RFC 7636)

SPA（Next.js Client Components 等）は、クライアントシークレットを安全に秘匿できない「Public Client」です。そのため、認可コード横取り攻撃を防ぐ **PKCE** の採用が不可欠となります。

### なぜ PKCE が必要なのか

従来の認可コードフローでは、リダイレクト時に認可コードが傍受されるリスクがありました。PKCE では、動的に生成した一回限りのパスワード（`code_verifier`）とそのハッシュ値（`code_challenge`）を用いることで、たとえ認可コードが奪われても、元の `code_verifier` を知らない攻撃者はトークン交換ができない仕組みを提供します。

---

## 3. トークン管理とストレージの選定：sessionStorage の妥当性

本プロジェクトでは、認証プロセスにおける一時データ（`code_verifier` 等）やトークンの保管に **`sessionStorage`** を優先的に採用します。これは、利便性よりもセキュリティの「攻撃表面の最小化」を優先した結果です。

### localStorage ではなく sessionStorage を選択する戦略的理由

1. **揮発性によるリスク低減:** `localStorage` はブラウザを閉じても残り続け、端末の紛失や共有 PC での利用時にデータが露出し続けるリスクがあります。`sessionStorage` はタブやウィンドウを閉じた瞬間に破棄されるため、攻撃者が情報を取得できる有効期間を最小限に制限できます。
2. **タブ間のアイソレーション:** `sessionStorage` はタブごとに独立したコンテキストを持ちます。これにより、予期せぬタブ間でのデータの競合や、あるタブで発生したセッションハイジャックが他のタブへ波及するのを防ぐことができます。
3. **PKCE 仕様との整合性:** `code_verifier` は認可リクエストからトークン取得までの極めて短い時間しか必要としません。永続化する必要がないため、揮発性ストレージである `sessionStorage` が最も仕様上の妥当性が高いと判断します。

---

## 4. FE/BE 境界線の設計（マルチベンダー環境の最適化）

多重下請けや複数チームが介在するプロジェクトでは、バックエンドの完成を待つことが最大のボトルネックとなります。これを打破するため、フロントエンド主導で以下の境界線を先行定義します。

### 4.1 インターフェースの先行合意

- **Claim の定義:** 認証後に ID トークンに含まれるべき属性（`sub`, `email`, `preferred_username`, `roles` 等）を早期に確定させ、フロントエンドのモック開発を可能にします。
- **エラースキーマ:** トークン期限切れ（401 Unauthorized）や権限不足（403 Forbidden）時のレスポンス形式を共通化し、フロントエンド側での統一的なエラーハンドリングを構築します。

### 4.2 認識齟齬の排除

「どのエンドポイントがどのスコープ（権限）を要求するか」を BE チームとマトリクス表等で早期に合意します。これにより、開発終盤での「権限不足で API が叩けない」といった手戻りを最小化し、プロジェクト全体のデリバリ速度を向上させます。
